\section{Bilan Technique}\label{sec:bilan-technique}

\subsection{Problèmes rencontrés et surmontés}\label{subsec:problemes-rencontres-et-surmontes}
Durant le développement du simulateur de conduite, nous avons rencontré et surmonté plusieurs difficultés, ce qui nous a permis d'approfondir nos compétences techniques et d'améliorer notre capacité à mener un bon travail en groupe.

\subsubsection{Gestion de Git}\label{subsubsec:git}
Tout au long du projet, nous avons utilisé \gls{git} et travaillé sur plusieurs \gls{git_branches} afin d'éviter les conflits de code lors du travail simultané sur les mêmes fichiers.
Malgré ces précautions, quelques conflits sont survenus lors des fusions de branches.
Avec le temps, nous avons appris à mieux gérer cette fonctionnalité de \gls{git} et à améliorer notre communication, réduisant ainsi significativement ces problèmes.

\subsubsection{Configuration avec \gls{cmake}}\label{subsubsec:cmake}
L'utilisation du fichier \texttt{CMakeLists.txt} pour gérer les bibliothèques et créer les différents exécutables a représenté un défi technique supplémentaire.
Les difficultés sont principalement survenues en raison des différences entre nos environnements de développement.
Bien que nous travaillions tous les deux sous Linux, l'un utilisait \gls{arch-linux} et l'autre \gls{ubuntu}, ce qui a engendré quelques disparités dans la gestion de certaines bibliothèques.

\subsubsection{Découverte de \gls{sfml}}\label{subsubsec:sfml}
Nous avons dû nous familiariser avec la bibliothèque \gls{sfml}, alors inconnue pour nous, et concevoir une interface graphique adaptée aux besoins du projet.
Cette phase d'apprentissage a été déterminante pour exploiter pleinement les fonctionnalités de \gls{sfml} et réaliser un rendu graphique efficace sans recourir à des techniques trop complexes.

\subsubsection{Gestion du temps et synchronisation}\label{subsubsec:la-gestion-du-temps}
La synchronisation des mises à jour, notamment la gestion du delta de temps entre les frames, a constitué un défi important.
Il a fallu ajuster nos méthodes de calcul du temps afin d’assurer une fluidité de l’animation et une réactivité optimale de l’interface.

\subsection{Retour sur les technologies utilisées}\label{subsec:retour-sur-les-technologies-utilisees}
Le choix du langage \gls{cpp} s'est révélé judicieux en raison de sa polyvalence et de ses performances.
Malgré une connaissance initiale limitée, ce projet nous a permis de progresser significativement dans sa maîtrise.
L'utilisation de \gls{sfml} a également été un atout majeur, simplifiant le développement d'interfaces graphiques interactives sans nécessiter de techniques trop complexes.
De plus \gls{gnuplot} nous a permis de pouvoir visualiser toutes les données produites par notre modèle, ce qui nous a permis de valider certaines fonctionnalités du modèle physique, et d'en corriger d'autres.

\subsection{Implémentation de la physique}\label{subsec:implem-phys}
En commançant notre projet, nous avons voulu implémenter trop de principes physiques en même temps, ce qui nous menait à de nombreuses erreurs.
Ceci nous a contraint à recommencer l'implémentation de la physique plusieurs fois.
Cette erreur nous a cependant appris qu'il ne faut pas essayer d'implémenter toutes les fonctionnalités en un bloc, mais de faire pas à pas.
C'est finalement en adoptant une manière itérative, en implémentant les différents phénomènes physique un à un, que nous avons réussi à avoir un modèle physique fonctionnel.

\subsection{Le manque de ressources}\label{subsec:manque-ressources}
L'étude de la dynamique des véhicules est quelque chose d'assez documenté, cependant aucune ressource que nous avons trouvée lie chaque phénomène physique que nous avons implémenté ensemble.
Nous avons donc dû fournir un travail de recherche approfondi pour pouvoir lier tous les phénomènes physiques entre eux.

\subsection{Le manque de données}\label{subsec:manque-data}
Similaire au manque de ressources, il y avait encore moins de données disponibles, cela voulait dire qu'après avoir implémenté les différentes formules trouvées, nous devions lancer notre modèle avec différentes données pour trouver les données qui donnaient les résultats obtenus.
De plus, cela nous a mené à plusieurs reprises, lorsqu'on implémentait une nouvelle fonctionnalité que cela casse totalement le code.
Celui-ci nous donnait alors des données dépassantes $9e^{12}$.
À chaque implémentation de nouvelles fonctionnalités, nous devions donc mener un travail de recherche pour identifier les variables qui nous posaient problème, puis en itérant notre modèle de nombreuses fois avec des données différentes, trouver les valeurs adaptées.



\subsection{Perspectives d'amélioration}\label{subsec:perspectives-d'ameliorations}
Pour une future amélioration du projet, nous avons identifié plusieurs axes d'améliorations :
\begin{itemize}
    \item Implémenter divers scénarios de conduite, afin d'offrir à l'utilisateur des expériences des différents phénomènes physiques implémentés.
    \item Comme proposé dans le sujet original, implémenter des phénomènes aléatoires, par exemple avoir un animal qui traverse la route, forçant l'utilisateur à changer sa trajectoire.
    \item Améliorer l'esthétique globale du projet, tant au niveau de l'interface graphique que des animations.
    \item Affiner le modèle physique en intégrant des phénomènes supplémentaires et en ajustant les paramètres pour une simulation encore plus réaliste.
    Plus précisément, on pourrait par exemple introduire un centre de gravité dynamique, ce qui permettrait de modéliser le transfert de forces du véhicule lors d'un freinage, d'une accélération ou de la prise d'un virage.
    \item La physique du modèle, pensée, initialement, uniquement pour l'interface graphique ne permet pas de générer une trajectoire sur un \texttt{dt} dépassant 9999.
    Bien que ce soit amplement suffisant pour l'interface, cette limite restraint la visualisation d'un scénario fixe en traçant les graphiques des différentes données.

\end{itemize}

\subsection{Ce que nous ferions différemment}\label{subsec:ce-que-nous-ferions-differemment}
Avec le recul, nous aurions intégré dès le départ des tests unitaires et d'intégration afin de détecter plus rapidement les erreurs et d'améliorer la robustesse du code.
Une phase de planification et de prototypage plus approfondie aurait permis de réduire les imprévus liés à l'apprentissage de nouvelles bibliothèques, notamment \gls{sfml}\@.
Ce changement méthodologique aurait sans doute accéléré le développement et renforcé la qualité du produit final.

\subsection{Mise en route du projet}\label{subsec:mise-en-route-du-projet}

\subsubsection{Dépendances}\label{subsubsec:dependances}
Pour compiler le projet, il est nécessaire d'installer les dépendances suivantes :
\begin{itemize}
    \item \textbf{Un compilateur supportant \gls{cpp}17} : par exemple, \texttt{clang++} ou \texttt{g++}.
    \item \texttt{\gls{cmake}} (version 3.30 ou supérieure) : pour la configuration et la gestion de la compilation.
    \item \texttt{\gls{sfml}} (versions $\left[2.5 ; 3.0\left[$) : pour la gestion de l'interface graphique et des entrées.
    \item \texttt{\gls{gnuplot}} : pour la génération des graphiques.
    \item \texttt{\gls{boost}} : utilisé pour la manipulation des flux, particulièrement en lien avec \texttt{\glspl{gnuplot}}.
    \item \texttt{\gls{googletest}} : installé automatiquement via le fichier \texttt{CMakeLists.txt}, pour la réalisation des tests unitaires.
\end{itemize}
\newpage
\subsubsection{Installation}\label{subsubsec:installation}
Le projet est disponible sur \gls{github} à l'adresse suivante : \url{https://github.com/QuentinRdl/Driving-Sim/}.

Pour l'installer, il est nécessaire de cloner le dépôt et de construire les exécutables correspondants aux différentes parties du projet grâce à ces commandes :

\begin{lstlisting}[style=bashStyle,label={lst:build}]
git clone 'https://github.com/QuentinRdl/Driving-Sim.git' && cd Driving-Sim
mkdir -p build && cd build
cmake ..
make
\end{lstlisting}
\noindent
Expliquons brièvement ces commandes :
\begin{itemize}
    \item La 1\textsuperscript{ère} ligne (\texttt{git clone}\dots) clone le dépôt et se rend dans le dossier cloné.
    \item La 3\textsuperscript{ème} ligne (\texttt{mkdir}\dots) crée un dossier \texttt{build} dans lequel on va construire les exécutables et s'y déplacer.
    \item Les lignes 4 (\texttt{cmake ..}) et 5 (\texttt{make}) permettent de configurer le projet et de compiler les exécutables.
\end{itemize}

\noindent
Une fois fait, il est possible de lancer les différents exécutables :
\begin{itemize}
    \item \texttt{Driving\_Sim} : pour le simulateur de conduite.
    \item \texttt{DrivingSim\_test} : pour les tests unitaires.
    \item \texttt{DrivingSim\_plot} : pour la génération des graphiques.
\end{itemize}
