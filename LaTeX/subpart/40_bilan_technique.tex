\section{Bilan Technique}\label{sec:bilan-technique}

\subsection{Retour sur le travail rendu}\label{subsec:retour-sur-le-travail-rendu}
Pour ce qui est de l'implémentation de la physique, nous avons réussi à rendre un travail que nous jugeons correct, il offre une simulation réaliste des dynamiques de déplacement d'une voiture.
Les calculs de mouvements et les interactions physiques se comportent de manière cohérente, ce qui fournit une bonne base l'interface graphique.
De plus, nous avons implémenté de quoi visualiser les différentes données générées par notre modèle avec les graphiques générés par \gls{gnuplot}.
Avec la possibilité de générer des graphiques, il est aisé d'identifier les tendances et anomalies éventuelles dans une trajectoire.

Notre interface graphique permet de manipuler une voiture en visualisant bien la trajectoire que celle-ci va suivre en fonction des commandes données par l'utilisateur.
Il est cependant important de noter que, malgré les avancées significatives dans notre prototype, nous avons manqué de temps pour intégrer différents scénarios de conduite.
Néanmoins, comme nous avons adopté une architecture de code modulaire, intégrer différents scénarios de conduite serait une chose plutôt aisée.

En conclusion, notre prototype intègre une physique plus que correcte, et malgré qu'il manque des scénarios de conduite, leur ajout serait sans difficultés majeures.

\subsection{Perspectives d'amélioration}\label{subsec:perspectives-d'ameliorations}
Pour une future amélioration du projet, nous avons identifié plusieurs axes d'améliorations :
\begin{itemize}
    \item Implémenter divers scénarios de conduite, afin d'offrir à l'utilisateur des expériences des différents phénomènes physiques implémentés.
    \item Comme proposé dans le sujet original, implémenter des phénomènes aléatoires, par exemple avoir un animal qui traverse la route, forçant l'utilisateur à changer sa trajectoire.
    \item Améliorer l'esthétique globale du projet, tant au niveau de l'interface graphique que des animations.
    \item Affiner le modèle physique en intégrant des phénomènes supplémentaires et en ajustant les paramètres pour une simulation encore plus réaliste.
    Plus précisément, on pourrait par exemple introduire un centre de gravité dynamique, ce qui permettrait de modéliser le transfert de forces du véhicule lors d'un freinage, d'une accélération ou de la prise d'un virage.
    \item La physique du modèle, pensée, initialement, uniquement pour l'interface graphique ne permet pas de générer une trajectoire sur un \texttt{dt} dépassant 9999.
    Bien que ce soit amplement suffisant pour l'interface, cette limite restraint la visualisation d'un scénario fixe en traçant les graphiques des différentes données.
    \item Pour une meilleure expérience utilisateur, nous pourrions également ajouter un moteur audio à notre simulateur.
    \item Ajouter une limite à certains paramètres de la physique, par exemple limiter l'angle de braquage maximum pour éviter d'avoir un véhicule qui peut faire un demi-tour presque sur lui-même.
    \item Améliorer la génération de graphiques, on pourrait par exemple, intégrer une fonctionnalité qui nous permettrait de superposer plusieurs courbes issues de deux scénarios quasi identiques, différant de juste une (ou plusieurs) variables, afin de voir ce qu'elles changent à la simulation.

\end{itemize}

\subsection{Problèmes rencontrés et surmontés}\label{subsec:problemes-rencontres-et-surmontes} %TODO : J'enleverrai 'et surmontés', car en plus je vais ajouter un truc qu'on a pas surmonté
Durant le développement du simulateur de conduite, nous avons rencontré et surmonté plusieurs difficultés, ce qui nous a permis d'approfondir nos compétences techniques et d'améliorer notre capacité à mener un bon travail en groupe.

\subsubsection{Gestion de Git}\label{subsubsec:git}
Tout au long du projet, nous avons utilisé \gls{git} et travaillé sur plusieurs \glspl{git_branches} afin d'éviter les conflits de code lors du travail simultané sur les mêmes fichiers.
Malgré ces précautions, quelques conflits sont survenus lors des fusions de branches.
Avec le temps, nous avons appris à mieux gérer cette fonctionnalité de \gls{git} et à améliorer notre communication, réduisant ainsi significativement ces problèmes.

\subsubsection{Configuration avec \gls{cmake}}\label{subsubsec:cmake}
L'utilisation du fichier \texttt{CMakeLists.txt} pour gérer les bibliothèques et créer les différents exécutables a représenté un défi technique supplémentaire.
Les difficultés sont principalement survenues en raison des différences entre nos environnements de développement.
Bien que nous travaillions tous les deux sous Linux, l'un utilisait \gls{arch-linux} et l'autre \gls{ubuntu}, ce qui a engendré quelques disparités dans la gestion de certaines bibliothèques.

\subsubsection{Découverte de \gls{sfml}}\label{subsubsec:sfml}
Nous avons dû nous familiariser avec la bibliothèque \gls{sfml}, alors inconnue pour nous, et concevoir une interface graphique adaptée aux besoins du projet.
Cette phase d'apprentissage a été déterminante pour exploiter pleinement les fonctionnalités de \gls{sfml} et réaliser un rendu graphique efficace sans recourir à des techniques trop complexes.

\subsubsection{Contrôle du véhicule}\label{subsubsec:ctrlVehicule}
Après avoir connecté l'interface graphique à notre moteur physique, nous avons constaté que lorsqu'on contrôle notre véhicule, celui-ci semble toujours être en glisse, comme s'il avait peu d'adhérence.
Comme c'était un phénomène que nous n'avons pas réussi à reproduire avec nos graphiques, nous avons déduit que cela doit venir de la manière dont nous avons connecté physique et interface graphique.

\subsubsection{Gestion du temps et synchronisation}\label{subsubsec:la-gestion-du-temps}
La synchronisation des mises à jour, notamment la gestion du delta de temps entre les frames, a constitué un défi important.
Il a fallu ajuster nos méthodes de calcul du temps afin d’assurer une fluidité de l’animation et une réactivité optimale de l’interface.

\subsubsection{Implémentation de la physique}\label{subsubsec:implem-phys}
En commençant notre projet, nous avons voulu implémenter trop de principes physiques en même temps, ce qui nous menait à de nombreuses erreurs.
Ceci nous a contraints à recommencer l'implémentation de la physique plusieurs fois.
Cette erreur nous a cependant appris qu'il ne faut pas essayer d'implémenter toutes les fonctionnalités en un bloc, mais de faire pas à pas.
C'est finalement en adoptant une manière itérative, en implémentant les différents phénomènes physique un à un, que nous avons réussi à avoir un modèle physique fonctionnel.

\subsubsection{Le manque de ressources}\label{subsubsec:manque-ressources}
L'étude de la dynamique des véhicules est quelque chose d'assez documenté, cependant aucune ressource que nous avons trouvée lie chaque phénomène physique que nous avons implémenté ensemble.
Nous avons donc dû fournir un travail de recherche approfondi pour pouvoir lier tous les phénomènes physiques entre eux.

\subsubsection{Le manque de données}\label{subsubsec:manque-data}
Similaire au manque de ressources, il y avait encore moins de données disponibles, cela voulait dire qu'après avoir implémenté les différentes formules trouvées, nous devions lancer notre modèle avec différentes données pour trouver les données qui donnaient les résultats obtenus.
De plus, cela nous a mené à plusieurs reprises, lorsqu'on implémentait une nouvelle fonctionnalité que cela casse totalement le code.
Celui-ci nous donnait alors des données dépassantes $9e^{12}$.
À chaque implémentation de nouvelles fonctionnalités, nous devions donc mener un travail de recherche pour identifier les variables qui nous posaient problème, puis en itérant notre modèle de nombreuses fois avec des données différentes, trouver les valeurs adaptées.

\subsection{Retour sur les technologies utilisées}\label{subsec:retour-sur-les-technologies-utilisees}
Le choix du langage \gls{cpp} s'est révélé judicieux en raison de sa polyvalence et de ses performances.
Malgré une connaissance initiale limitée, ce projet nous a permis de progresser significativement dans sa maîtrise.
L'utilisation de \gls{sfml} a également été un atout majeur, simplifiant le développement d'interfaces graphiques interactives sans nécessiter de techniques trop complexes.
De plus \gls{gnuplot} nous a permis de pouvoir visualiser toutes les données produites par notre modèle, ce qui nous a permis de valider certaines fonctionnalités du modèle physique, et d'en corriger d'autres.






\subsection{Retour sur nos méthodes de travail}\label{subsec:retour-sur-nos-methodes-de-travail}
Au commencement de notre projet, nous nous sommes réunis pour planifier la manière dont nous allions procéder pour implémenter notre simulateur.
Il s'est rapidement révélé que notre simulateur serait séparé en deux grandes parties, la partie physique et la partie interface graphique.
Après réflexion, nous avons décidé de nous attribuer une partie jusqu'à la fin du projet.
L'idée était déjà d'implémenter une physique très simple, et en parallèle programmer le début de l'interface graphique.
Une fois la première version de l'interface graphique terminée, elle fut connecté à la version très simplifiée de la physique.
Ainsi, nous pouvions travailler indépendamment, sans attendre que l'autre membre du groupe finisse une certaine tache, pour en avancer sur une autre.
Il nous a seulement fallu quelques moments de synchronisation pour interconnecter nos \glspl{git_branches} \gls{git}, mais rien de trop contraignant.
Cette manière de travailler asynchrone s'est révélée très productive pour ce projet.
Néanmoins, nous nous réunissions souvent pour discuter des avancées de chaque partie du projet, pour planifier les prochaines tâches à effectuer, et s'assurer que nous avions la même vision pour la suite du projet.
Cette manière de procéder nous assurait de rester au fil des dernières implémentations de l'autre partie, et de comprendre les taches que devait mener l'autre membre du binôme.

\subsection{Ce que nous ferions différemment}\label{subsec:ce-que-nous-ferions-differemment}
Avec le recul, nous aurions intégré dès le départ des tests unitaires et d'intégration afin de détecter plus rapidement les erreurs et d'améliorer la robustesse du code.
Une phase de planification et de prototypage plus approfondie aurait permis de réduire les imprévus liés à l'apprentissage de nouvelles bibliothèques, notamment \gls{sfml}\@.
Ce changement méthodologique aurait sans doute accéléré le développement et renforcé la qualité du produit final.

\subsection{Mise en route du projet}\label{subsec:mise-en-route-du-projet}

\subsubsection{Dépendances}\label{subsubsec:dependances}
Pour compiler le projet, il est nécessaire d'installer les dépendances suivantes :
\begin{itemize}
    \item \textbf{Un compilateur supportant \gls{cpp}17} : par exemple, \texttt{clang++} ou \texttt{g++}.
    \item \texttt{\gls{cmake}} (version 3.30 ou supérieure) : pour la configuration et la gestion de la compilation.
    \item \texttt{\gls{sfml}} (versions $\left[2.5 ; 3.0\left[$) : pour la gestion de l'interface graphique et des entrées.
    \item \texttt{\gls{gnuplot}} : pour la génération des graphiques.
    \item \texttt{\gls{boost}} : utilisé pour la manipulation des flux, particulièrement en lien avec \texttt{\glspl{gnuplot}}.
    \item \texttt{\gls{googletest}} : installé automatiquement via le fichier \texttt{CMakeLists.txt}, pour la réalisation des tests unitaires.
\end{itemize}

\subsubsection{Installation}\label{subsubsec:installation}
Le projet est disponible sur \gls{github} à l'adresse suivante : \url{https://github.com/QuentinRdl/Driving-Sim/}.

Pour l'installer, il est nécessaire de cloner le dépôt et de construire les exécutables correspondants aux différentes parties du projet grâce à ces commandes :

\begin{lstlisting}[style=bashStyle,label={lst:build}]
git clone 'https://github.com/QuentinRdl/Driving-Sim.git' && cd Driving-Sim
mkdir -p build && cd build
cmake ..
make
\end{lstlisting}
\noindent
Expliquons brièvement ces commandes :
\begin{itemize}
    \item La 1\textsuperscript{ère} ligne (\texttt{git clone}\dots) clone le dépôt et se rend dans le dossier cloné.
    \item La 3\textsuperscript{ème} ligne (\texttt{mkdir}\dots) crée un dossier \texttt{build} dans lequel on va construire les exécutables et s'y déplacer.
    \item Les lignes 4 (\texttt{cmake ..}) et 5 (\texttt{make}) permettent de configurer le projet et de compiler les exécutables.
\end{itemize}

\noindent
Une fois fait, il est possible de lancer les différents exécutables :
\begin{itemize}
    \item \texttt{Driving\_Sim} : pour le simulateur de conduite.
    \item \texttt{DrivingSim\_test} : pour les tests unitaires.
    \item \texttt{DrivingSim\_plot} : pour la génération des graphiques.
\end{itemize}
